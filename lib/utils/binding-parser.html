<!--
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="boot.html">
<link rel="import" href="path.html">
<script>
(function() {
    'use strict';

    const BINDINGS = {
        '{': '}',
        '[': ']'
    };

    function pushLiteral(text, i, parts, startChar) {
        const literal = text.substring(startChar || 0, i);
        if (literal) {
            parts.push({
                literal
            });
        }
    }

    function storeMethod(bindingData, templateInfo) {
        const methodName = bindingData.signature.methodName;
        const dynamicFns = templateInfo.dynamicFns;
        if (dynamicFns && dynamicFns[methodName] || bindingData.signature.static) {
            bindingData.dependencies.push(methodName);
            bindingData.signature.dynamicFn = true;
        }
    }

    function storeVariableBinding(parts, bindingData, prop, i) {
        bindingData.source = prop;
        bindingData.dependencies.push(prop);
        bindingData.startChar = i + 1;
        parts.push(bindingData);
    }

    function storeMethodVariable(bindingData, text, i) {
        const name = text.substring(bindingData.startChar, i).trim();
        if (name) {
            if (name === 'true' || name === 'false') {
                bindingData.signature.args.push({
                    name,
                    value: name == 'true',
                    literal: true
                });
            } else {
                const arg = {
                    name
                }
                arg.structured = Polymer.Path.isPath(name);
                if (arg.structured) {
                    arg.wildcard = (name.slice(-2) == '.*');
                    if (arg.wildcard) {
                        arg.name = name.slice(0, -2);
                    }
                }
                bindingData.signature.args.push(arg);
                bindingData.dependencies.push(name)
                bindingData.signature.static = false;
            }
        }
    }

    function storeMethodNumber(bindingData, text, i) {
        const value = text.substring(bindingData.startChar, i).trim();
        bindingData.signature.args.push({
            name: value,
            value: Number(value),
            literal: true
        });
    }

  /**
   * Module with utilities for converting between "dash-case" and "camelCase"
   * identifiers.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for converting between "dash-case"
   *   and "camelCase".
   */
  const BindingParser = {

    parse(text, templateInfo) {
        const parts = [];
        /* eslint-disable no-fallthrough */

        const STATE = {
            INITIAL: bindingData => char => {
                if ((char === '{' || char === '[')) {
                    return STATE.FIRSTOPENINGBINDING({
                        mode: char,
                        dependencies: [],
                        startChar: bindingData.startChar
                    });
                }
            },
            FIRSTOPENINGBINDING: bindingData => (char, i) => {
                if (char === bindingData.mode) {
                    pushLiteral(text, i - 1, parts, bindingData.startChar);
                    bindingData.startChar = i + 1;
                    return STATE.FIRSTCHARACTERBINDING(bindingData);
                }
                return STATE.INITIAL({});
            },
            FIRSTCHARACTERBINDING: (bindingData) => char => {
                if (char !== ' ' && char !== '\t' && char !== '\n') {
                    if (char === '!') {
                        bindingData.negate = true;
                        bindingData.startChar = i + 1;
                    }
                    return STATE.BINDING(bindingData)
                }
            },
            BINDING: bindingData => (char, i) => {
                switch (char) {
                    case BINDINGS[bindingData.mode]: {
                        return STATE.FIRSTCLOSINGBINDING(bindingData);
                    }
                    case '\'':
                    case '"': {
                        return STATE.STRING(bindingData, char);
                    }
                    case '(': {
                        bindingData.signature = {
                            methodName: text.substring(bindingData.startChar, i).trim(),
                            args: [],
                            static: true
                        };
                        return STATE.METHOD(bindingData)
                    }
                    case ':': {
                        return STATE.FIRSTCOLON(bindingData)
                    }
                }
            },
            FIRSTCOLON: bindingData => (char, i) => {
                if (char === ':') {
                    bindingData.customEvent = true;
                    bindingData.startCharAfterColon = i + 1;
                    return STATE.COLONNOTIFYEVENT(bindingData)
                }
                return STATE.BINDING(bindingData)
            },
            COLONNOTIFYEVENT: bindingData => char => {
                if (char === BINDINGS[bindingData.mode]) {
                    return STATE.COLONNOTIFYEVENTFIRSTCLOSINGBINDING(bindingData);
                }
            },
            COLONNOTIFYEVENTFIRSTCLOSINGBINDING: bindingData => char => {
                if (char === BINDINGS[bindingData.mode]) {
                    bindingData.event = text.substring(bindingData.startCharAfterColon, i - 1).trim();
                    const prop = text.substring(bindingData.startChar, bindingData.startCharAfterColon - 2).trim();
                    storeVariableBinding(parts, bindingData, prop, i);
                    return STATE.INITIAL(bindingData);
                }
                return STATE.BINDING(bindingData);
            },
            FIRSTCLOSINGBINDING: bindingData => (char, i) => {
                if (char === BINDINGS[bindingData.mode]) {
                    const prop = text.substring(bindingData.startChar, i - 1).trim();
                    storeVariableBinding(parts, bindingData, prop, i);
                    return STATE.INITIAL(bindingData);
                }
                return STATE.BINDING(bindingData);
            },
            STRING: (bindingData, quote) => {
                let escaped = false;
                return char => {
                    if (char === '\\') {
                        escaped = true;
                    } else if (char === quote && !escaped) {
                        return STATE.BINDING(bindingData)
                    } else {
                        escaped = false;
                    }
                }
            },
            METHOD: (bindingData) => {
                bindingData.startChar = i + 1;
                return (char, i) => {
                    switch (char) {
                        case ')': {
                            storeMethodVariable(bindingData, text, i);
                            storeMethod(bindingData, templateInfo);
                            bindingData.startChar = i + 1;
                            return STATE.METHODCLOSED(bindingData);
                        }
                        case ',': {
                            storeMethodVariable(bindingData, text, i)
                            bindingData.startChar = i + 1;
                            break;
                        }
                        case '\'':
                        case '"': {
                            return STATE.STRINGARG(bindingData, char);
                        }
                        default: {
                            if (char >= '0' && char <= '9' || char === '-') {
                                return STATE.NUMBERARG(bindingData)
                            }

                            if (char != ' ' && char != '\n') {
                                return STATE.VARIABLEARG(bindingData)
                            }
                        }
                    }
                }
            },
            STRINGARG: (bindingData, quote) => {
                let escaped = false;
                return char => {
                    if (char === '\\') {
                        escaped = true;
                    } else if (char === quote && !escaped) {
                        const value = text.substring(bindingData.startChar, i)
                                .replace(/^\s+/, '')
                                .substring(1)
                                // replace comma entity with comma
                                .replace(/&comma;/g, ',')
                                // repair extra escape sequences; note only commas strictly need
                                // escaping, but we allow any other char to be escaped since its
                                // likely users will do this
                                .replace(/\\(.)/g, '\$1');
                        bindingData.signature.args.push({
                            value,
                            name: value,
                            literal: true
                        });
                        return STATE.METHOD(bindingData)
                    } else {
                        escaped = false;
                    }
                }
            },
            NUMBERARG: bindingData => char => {
                switch (char) {
                    case ',': {
                        storeMethodNumber(bindingData, text, i);
                        return STATE.METHOD(bindingData);
                    }
                    case ')': {
                        storeMethodNumber(bindingData, text, i);
                        return STATE.METHODCLOSED(bindingData);
                    }
                    default: {
                        if (char < '0' || char > '9') {
                            return STATE.VARIABLEARG(bindingData);
                        }
                    }
                }
            },
            VARIABLEARG: bindingData => char => {
                switch (char) {
                    case ',': {
                        storeMethodVariable(bindingData, text, i);
                        return STATE.METHOD(bindingData)
                    }
                    case ')': {
                        storeMethodVariable(bindingData, text, i);
                        return STATE.METHODCLOSED(bindingData)
                    }
                }
            },
            METHODCLOSED: bindingData => {
                storeMethod(bindingData, templateInfo);
                return char => {
                    if (char === BINDINGS[bindingData.mode]) {
                        return STATE.METHODCLOSEDBINDING(bindingData);
                    }
                    if (char !== ' ' && char !== '\t' && char !== '\n') {
                        console.warn(`Invalid binding: "${text}"`);
                    }
                }
            },
            METHODCLOSEDBINDING: bindingData => (char, i) => {
                if (char === BINDINGS[bindingData.mode]) {
                    bindingData.startChar = i + 1;
                    parts.push(bindingData);
                    return STATE.INITIAL(bindingData);
                }
                if (char !== ' ' && char !== '\t' && char !== '\n') {
                    console.warn(`Invalid binding: "${text}"`);
                }
            }
        }
        /* eslint-enable no-fallthrough */

        let state = STATE.INITIAL({});
        let i,l;

        for (i=0,l=text.length; i<l; i++) {
            state = state(text.charAt(i), i) || state;
        }

        if (parts.length) {
            pushLiteral(text, i, parts, parts[parts.length - 1].startChar);
        }

        return parts;
    }
  }

  Polymer.BindingParser = BindingParser;
})();
</script>
